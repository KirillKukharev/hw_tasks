"""
№ 1 Разработайте класс ComplexNumber, который представляет собой комплексное число и поддерживает следующие операции:

Сложение: Реализуйте метод __add__, который позволяет складывать два комплексных числа. При сложении комплексных чисел (a + bi) и (c + di) результатом будет комплексное число (a + c) + (b + d)i.

Умножение: Реализуйте метод __mul__, который позволяет умножать два комплексных числа. При умножении комплексных чисел (a + bi) и (c + di) результатом будет комплексное число (ac - bd) + (ad + bc)i.

Модуль: Реализуйте метод __abs__, который возвращает модуль (или длину) комплексного числа. Модуль комплексного числа (a + bi) вычисляется как √(a^2 + b^2).

Сравнение на равенство: Реализуйте метод __eq__, который позволяет сравнивать два комплексных числа на равенство. Два комплексных числа равны, если их действительные и мнимые части равны.

Сравнение по модулю: Реализуйте метод __lt__, который позволяет сравнивать два комплексных числа по их модулю. Комплексное число меньше другого, если его модуль меньше модуля другого числа.

Представление: Реализуйте метод __repr__, который возвращает строковое представление комплексного числа в формате a + bi.

"""


class ComplexNumber:
    def __init__(self, re_num:int=0, im_num:int=0):
        self.__re_num = re_num
        self.__im_num = im_num
    
    def getRe(self)-> int:
        return self.__re_num
    
    def getIm(self)-> int:
        return self.__im_num

    def __repr__(self)-> "ComplexNumber":
        return f"{self.getRe()}+{self.getIm()}i"

    def __add__(self, add_num:"ComplexNumber"):
        return ComplexNumber(self.getRe()+add_num.getRe(), self.getIm()+add_num.getIm())

    def __mul__(self, add_num:"ComplexNumber"):
        return ComplexNumber((self.getRe()*add_num.getRe())-(self.getIm()*add_num.getIm()), ((self.getRe()*add_num.getIm())+(self.getIm()*add_num.getRe())))
    
    def __abs__(self)->int:
        return abs(self.getRe()**2 + self.getIm()**2)

    def __eq__(self, compair_num)->bool:
        return True if (self.getRe() == compair_num.getRe()) and (self.getIm() == compair_num.getIm()) else False

    def __lt__(self, compair_num)->bool:
        return True if (abs(self) < abs(compair_num)) else False
"""
№ 2 Реализация Менеджера Контекста для Управления Файлами с Логированием Ошибок

Реализовать класс FileManagerWithLogging, который будет использоваться как менеджер контекста для управления фTrайлами и логирования ошибок.

Конструктор __init__

Параметры:
filename: Имя файла для открытия.
mode: Режим открытия файла (например, 'r', 'w', 'a' и т.д.).
log_filename (по умолчанию "error_log.txt"): Имя файла для записи логов ошибок.
Инициализируйте атрибуты класса с переданными значениями.
Метод __enter__

Откройте файл с использованием переданных filename и mode.
Верните открытый файл для использования в блоке with.
Метод __exit__

При возникновении исключения:
Запишите сообщение об ошибке в файл лога (log_filename), используя формат: Error: <текст ошибки>.
Закройте файл, независимо от того, возникло ли исключение или нет.
"""


class FileManagerWithLogging:
    
    def __init__(self, filename:str, method:str="r", log_file:str = "error_log.txt"):
        self.filename = filename
        self.log_file = log_file
        self.method = method
        self.file_obj = None

    def __enter__(self):
        
        try:
            self.file_obj = open(self.filename, self.method)
        except Exception as ex:
            self.logger(type(ex), ex)
            raise ex          
        return self.file_obj
        
        
    def __exit__(self, type_error, value, traceback):
        if self.file_obj != None:
            self.file_obj.close()
        if type_error != None:
            self.logger(type_error, value)
        
    def logger(self, type_error, value):
        try:
            self.error_log = open(self.log_file, "a")
            self.error_log.write(f"Error_type:{type_error} - Text: {value}\n")     
        finally:
            self.error_log.close()
        
        


# Пример использования
def write_to_file_with_logging(filename, content):
    with FileManagerWithLogging(filename, "w") as f:
        f.write(content)


"""
№ 3 Напишите функцию, которая создает замыкание для инкрементации значения.
Замыкание должно позволять динамически изменять шаг инкрементации,
сохраняя при этом текущее состояние. Кроме того, добавьте возможность сброса значения.
"""


def create_incrementer(start=0):
    pass


"""
№ 4 Создание асинхронного обработчика задач

Вам необходимо создать асинхронный обработчик задач с использованием модуля asyncio.
Напишите два асинхронных метода, которые реализуют следующую логику:

async_task(n): Этот метод принимает целое число n и выполняет следующее:

Если n четное, метод должен ожидать 1 секунду (используя await asyncio.sleep(1)) и вернуть строку вида "Task {n} completed".
Если n нечетное, метод должен возбуждать исключение ValueError с сообщением вида "Task {n} failed".
run_tasks(task_list): Этот метод принимает список целых чисел task_list и выполняет следующие действия:

Создает список асинхронных задач, вызывая async_task(n) для каждого числа n в task_list.
Обрабатывает каждую задачу с использованием вложенного асинхронного метода handle_task(n),
который вызывает async_task(n) и возвращает результат, или строку с описанием ошибки, если задача завершилась с исключением.
Сбор всех результатов и исключений в виде списка строк и возвращение этого списка.
"""

import asyncio


async def async_task(n):
    pass


async def run_tasks(task_list):
    results = []

    async def handle_task(n):
        pass


"""
№ 5 Поиск с валидацией

Вам необходимо реализовать два связанных метода для поиска элемента в отсортированном списке.

Метод binary_search(sorted_list, target)

Реализуйте функцию для выполнения бинарного поиска в отсортированном списке.
Эта функция должна принимать два аргумента:

sorted_list — отсортированный список элементов (список целых чисел).
target — элемент, который нужно найти.
Функция должна вернуть индекс target в sorted_list, если он присутствует в списке, и -1, если элемент не найден.

Метод search_with_validation(lst, target)

Реализуйте функцию, которая сначала проверяет, отсортирован ли список, и затем вызывает binary_search.
Эта функция должна принимать два аргумента:

lst — список целых чисел.
target — элемент, который нужно найти.
Если lst не отсортирован, функция должна возбуждать исключение ValueError с сообщением "List must be sorted".
В противном случае функция должна вызвать binary_search для выполнения поиска и вернуть результат.
"""


def binary_search(sorted_list, target):
    pass


def search_with_validation(lst, target):
    if lst != sorted(lst):
        raise ValueError("List must be sorted")
    return binary_search(lst, target)


"""
№ 6 Реализация Декоратора Кеширования и Повторов

Напишите декоратор cache_and_retry, который комбинирует два поведения:

Кеширование: Сохраняет результаты вызовов функции для уникальных наборов аргументов.
Если функция вызывается с теми же аргументами, кешированный результат возвращается немедленно, без повторного выполнения функции.
Повторные Попытки: Если функция вызывает исключение, повторите её выполнение несколько раз с заданной задержкой между попытками. 
Если после всех попыток функция всё ещё не выполняется успешно, исключение должно быть выброшено.
Детали
Декоратор cache_and_retry должен принимать два параметра:

retries: Количество попыток выполнить функцию (по умолчанию 3).
delay: Задержка между попытками в секундах (по умолчанию 1).
Декоратор должен использовать кеширование для хранения результатов вызовов функции. Кеширование должно быть реализовано с использованием словаря, где ключом является кортеж аргументов функции.

Декоратор должен работать следующим образом:

При первом вызове функции с определёнными аргументами, декоратор выполняет функцию и сохраняет результат в кеше.
При повторном вызове функции с теми же аргументами, декоратор возвращает результат из кеша.
Если функция вызывает исключение, декоратор делает попытку повторного выполнения до тех пор, пока не будет достигнуто максимальное количество попыток.
В случае успеха возвращается результат; в противном случае исключение выбрасывается.
"""

import functools
import time


def cache_and_retry(retries=3, delay=1):
    cache = {}

    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            pass
